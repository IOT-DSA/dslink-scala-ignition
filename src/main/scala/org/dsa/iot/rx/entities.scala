package org.dsa.iot.rx

import scala.collection.mutable.ArrayBuffer

import org.dsa.iot.util.Logging

import rx.lang.scala.{ Observable, Subscription }
import rx.lang.scala.subjects.BehaviorSubject

/**
 * A block that emits items of type Observable[R].
 */
trait RxBlock[+R] {

  /**
   * Returns the Observable generated by this block.
   */
  def observe: Observable[R]

  /**
   * Returns the block's output as an Observable. This observable is stable in the sense that
   * it keeps emitting items, whether the block has been reset, or its inputs changed etc., i.e.
   * it never calls `onError` or `onCompleted` methods on its subscribers until the block's
   * `shutdown()` method is called.
   */
  val output: Observable[R]

  /**
   * Restarts the block.
   */
  def reset(): Unit

  /**
   * Stops the data flow through the block.
   */
  def shutdown(): Unit
}

/**
 * Top of RxBlock hierarchy.
 */
abstract class AbstractRxBlock[R] extends RxBlock[R] with Logging { self =>

  /**
   * computes the block's output
   */
  protected def compute: Observable[R]

  /**
   * Ports connected to this block's output.
   */
  private val targets = collection.mutable.Set.empty[AbstractRxBlock[_]#Port[_ >: R]]

  /**
   * "stable" observable, will never get onError or onCompleted
   */
  private val subj = BehaviorSubject[R]()
  lazy val output = withEvents("output")(subj).share

  /**
   * Output subscription.
   */
  private var obs: Observable[R] = Observable.never
  private var subscription: Option[Subscription] = None

  /**
   * The currently established Observable output.
   */
  def observe = obs

  /**
   * Resets the block by renewing the subscriptions and re-initiating the sequence.
   */
  def reset() = synchronized {
    unsubsribeOutput

    obs = withEvents("output")(compute).share
    subscription = Some(obs subscribe (subj.onNext(_)))

    targets foreach (_.bind(obs, Some(this)))
    targets map (_.owner) foreach (_.reset)
  }

  /**
   * Cancels all subscriptions and stops emitting items.
   */
  def shutdown() = synchronized {
    unsubsribeOutput
    subj.onCompleted

    targets foreach (_.unbind)
    targets map (_.owner) foreach (_.reset)

    targets.clear
  }

  /**
   * Connects the output of this block to an input port of another block.
   */
  def to[T](port: AbstractRxBlock[T]#Port[_ >: R]): port.owner.type = synchronized {
    port.unset

    targets += port
    port.bind(obs, Some(this))

    info(s"${port.owner.id}.${port.name} bound to $id.output")
    port.owner
  }

  /**
   * Connects the output of this block to an input port of another block.
   * An alias for `to(port)`.
   */
  def ~>[T](port: AbstractRxBlock[T]#Port[_ >: R]) = to(port)

  /**
   * Connects the output of this block to `source` input port of a transformer block.
   */
  def to[U](block: RxTransformer[_ >: R, U]): block.type = {
    to(block.source)
    block
  }

  /**
   * Connects the output of this block to `source` input port of a transformer block.
   * An alias for `to(block)`.
   */
  def ~>[U](block: RxTransformer[_ >: R, U]): block.type = to(block)

  /**
   * Cancels the output subscription.
   */
  protected def unsubsribeOutput() = subscription foreach (_.unsubscribe)

  /**
   * Decorates the observable by adding listeners for its lifecycle events.
   */
  protected def withEvents(name: String)(stream: Observable[R]): Observable[R] = {
    def render(state: String) = debug(s"[$id.$name] $state")

    stream
      .doOnCompleted(render("completed"))
      .doOnSubscribe(render("subscribed to"))
      .doOnTerminate(render("terminated"))
      .doOnUnsubscribe(render("unsubscribed from"))
  }

  /**
   * Generates block's id for logging.
   */
  protected val id = getClass.getSimpleName + (math.abs(hashCode) % 1000)

  /**
   * Removes the specified port from the list of targets and unbinds it.
   * This method is called from port's `unset` method and should not be called directly.
   */
  private def disconnect[T](port: AbstractRxBlock[T]#Port[_ >: R]) = synchronized {
    targets -= port
    port.unbind
    info(s"${port.owner.id}.${port.name} disconnected from $id.output")
  }

  /**
   * Connector for attributes and inputs. Provides the input as Observable[X].
   */
  case class Port[X](name: String) {
    val owner = self

    private var _in: Observable[X] = Observable.never
    private var _srcBlock: Option[AbstractRxBlock[_ <: X]] = None

    /**
     * Block's input as Observable[X].
     */
    def in = _in

    /**
     * Binds this port to an observable, optionally specifying the source block.
     */
    private[AbstractRxBlock] def bind(source: Observable[X], block: Option[AbstractRxBlock[_ <: X]]) = synchronized {
      _in = source
      _srcBlock = block
    }

    /**
     * Disconnects the port from any source so that it never emits any values.
     */
    private[AbstractRxBlock] def unbind() = synchronized {
      _in = Observable.never
      _srcBlock = None
    }

    /**
     * Assign a specific value to this port.
     */
    def set(value: X) = synchronized {
      unset
      _in = Observable.just(value)
      info(s"$id.$name set to $value")
    }

    /**
     * Assign a specific value to this port.
     * An alias for `set(value)`.
     */
    def <~(value: X) = set(value)

    /**
     * Connects this port to the output of another block.
     */
    def from(block: AbstractRxBlock[_ <: X]): Unit = block to this

    /**
     * Connects this port to the output of another block.
     * An alias for `from(block)`.
     */
    def <~(block: AbstractRxBlock[_ <: X]) = from(block)

    /**
     * Connects this port to an arbitrary Observable.
     */
    def from(src: Observable[_ <: X]) = {
      unset
      bind(src, None)
      info(s"${owner.id}.${name} bound to $src")
    }

    /**
     * Connects this port to an arbitrary Observable.
     * An alias for `from(src)`.
     */
    def <~(src: Observable[_ <: X]) = from(src)

    /**
     * Disconnects this port from the input source.
     */
    def unset() = {
      _srcBlock foreach (_.disconnect(this))
      _srcBlock = None
    }
  }

  /**
   * Connector for a list of attributes or inputs.
   */
  case class PortList[X](name: String) extends IndexedSeq[Port[X]] {
    val ports = ArrayBuffer.empty[Port[X]]

    /**
     * Returns a collection of input observables, one from each port.
     */
    def ins = ports map (_.in) toIndexedSeq

    /**
     * Combines all input observables into a single observable of a Seq[X].
     */
    def combinedIns = Observable.combineLatest(ins.toIterable)(identity)

    /**
     * Returns the specified port.
     */
    def apply(index: Int) = if (index < ports.size) ports(index) else {
      add(index - ports.size + 1)
      ports(index)
    }

    /**
     * Returns the number of ports in the list.
     */
    def length = ports.length

    /**
     * Adds a new port to the list.
     */
    def add(): Port[X] = {
      val index = ports.length
      val port = Port[X](s"$name($index)")
      ports += port
      info(s"$id.$name added port $index")
      port
    }

    /**
     * Adds a few new ports to the list.
     */
    def add(count: Int): Unit = (1 to count) foreach (_ => add)

    /**
     * Clears the current associations and assigns the set of items to the ports.
     */
    def set(items: X*): Unit = {
      ports.clear
      items foreach (_ => add)
      ports zip items foreach {
        case (port, item) => port.set(item)
      }
      info(s"$id.$name set to $items")
    }

    /**
     * Clears the current associations and assigns the set of items to the ports.
     * An alias for `set(items)`.
     */
    def <~(items: X*) = set(items: _*)

    /**
     * Removes the last port in the list.
     */
    def removeLast() = {
      val index = ports.length - 1
      val port = ports.remove(index)
      port.unset
      info(s"$id.$name($index) port removed")
    }

    /**
     * Removes all ports from the list.
     */
    def clear() = {
      ports foreach (_.unset)
      ports.clear
      info(s"$id.$name all ports removed")
    }
  }
}

/**
 * A block that has one input.
 */
abstract class RxTransformer[T, R] extends AbstractRxBlock[R] {
  val source = Port[T]("source")

  def from(block: AbstractRxBlock[_ <: T]) = source from block

  def <~(block: AbstractRxBlock[_ <: T]) = from(block)
}

/**
 * A block that has two inputs.
 */
abstract class RxMerger2[T1, T2, R] extends AbstractRxBlock[R] {
  val source1 = Port[T1]("source1")
  val source2 = Port[T2]("source2")

  def from(a: AbstractRxBlock[_ <: T1], b: AbstractRxBlock[_ <: T2]) = {
    source1 from a
    source2 from b
  }

  def <~(a: AbstractRxBlock[_ <: T1], b: AbstractRxBlock[_ <: T2]) = from(a, b)
}

/**
 * A block that has three inputs.
 */
abstract class RxMerger3[T1, T2, T3, R] extends AbstractRxBlock[R] {
  val source1 = Port[T1]("source1")
  val source2 = Port[T2]("source2")
  val source3 = Port[T3]("source3")

  def from(a: AbstractRxBlock[_ <: T1], b: AbstractRxBlock[_ <: T2], c: AbstractRxBlock[_ <: T3]) = {
    source1 from a
    source2 from b
    source3 from c
  }

  def <~(a: AbstractRxBlock[_ <: T1], b: AbstractRxBlock[_ <: T2], c: AbstractRxBlock[_ <: T3]) = from(a, b, c)
}

/**
 * A block that has four inputs.
 */
abstract class RxMerger4[T1, T2, T3, T4, R] extends AbstractRxBlock[R] {
  val source1 = Port[T1]("source1")
  val source2 = Port[T2]("source2")
  val source3 = Port[T3]("source3")
  val source4 = Port[T4]("source4")

  def from(a: AbstractRxBlock[_ <: T1], b: AbstractRxBlock[_ <: T2], c: AbstractRxBlock[_ <: T3], d: AbstractRxBlock[_ <: T4]) = {
    source1 from a
    source2 from b
    source3 from c
    source4 from d
  }

  def <~(a: AbstractRxBlock[_ <: T1], b: AbstractRxBlock[_ <: T2], c: AbstractRxBlock[_ <: T3], d: AbstractRxBlock[_ <: T4]) = from(a, b, c, d)
}

/**
 * A block that has a list of inputs of the same type.
 */
abstract class RxMergerN[T, R] extends AbstractRxBlock[R] {
  val sources = PortList[T]("sources")
}

/**
 * Wraps a structure of interconnected blocks and behaves as one block.
 */
abstract class RxPipeline[R] extends AbstractRxBlock[R] {

  /**
   * The block whose output is exposed as the pipeline's output.
   */
  protected val target: AbstractRxBlock[R]

  /**
   * All blocks that comprise this pipeline.
   */
  protected val allBlocks: Iterable[RxBlock[_]]

  /**
   * Called to bind the input ports of the pipeline to the input ports of its constituents.
   */
  protected def bindPorts(): Unit

  /**
   * The blocks that need to be reset each time the pipeline's `reset` method is called.
   * By default, it is equal to `allBlocks`.
   */
  protected val blocksToReset: Iterable[RxBlock[_]] = allBlocks

  /**
   * Computes the target block's output.
   */
  protected def compute = target.observe

  /**
   * Resets all internal blocks that need to be reset.
   */
  override def reset() = {
    bindPorts
    blocksToReset foreach (_.reset)
    super.reset
  }

  /**
   * Shuts down all its internal blocks.
   */
  override def shutdown() = {
    allBlocks foreach (_.shutdown)
    super.shutdown
  }
}